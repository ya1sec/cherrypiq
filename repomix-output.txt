This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: cherrypiq.js, fix-cherrypiq.sh, install-cherrypiq.sh
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
cherrypiq.js
fix-cherrypiq.sh
install-cherrypiq.sh

================================================================
Files
================================================================

================
File: cherrypiq.js
================
#!/usr/bin/env node

const blessed = require("blessed");
const fs = require("fs");
const path = require("path");
const { execSync, spawn } = require("child_process");
const { promisify } = require("util");
const readdir = promisify(fs.readdir);
const stat = promisify(fs.stat);
const readFile = promisify(fs.readFile);
const clipboardy = require("clipboardy");

// Handle update command
if (process.argv[2] === "update") {
  const currentDir = process.cwd();
  const cherrypiqJs = path.join(currentDir, "cherrypiq.js");
  const cherrypiqInstallDir = path.join(process.env.HOME, ".cherrypiq");

  // Check if cherrypiq.js exists in current directory
  if (!fs.existsSync(cherrypiqJs)) {
    console.error("Error: cherrypiq.js not found in current directory.");
    console.error(
      "Please run this command from the directory containing your modified cherrypiq.js"
    );
    process.exit(1);
  }

  // Check if ~/.cherrypiq exists
  if (!fs.existsSync(cherrypiqInstallDir)) {
    console.error("Error: cherrypiq installation directory not found.");
    console.error("Please install cherrypiq first using install-cherrypiq.sh");
    process.exit(1);
  }

  try {
    // Copy the local cherrypiq.js to the installation directory
    console.log("Copying local cherrypiq.js to installation directory...");
    fs.copyFileSync(
      cherrypiqJs,
      path.join(cherrypiqInstallDir, "cherrypiq.js")
    );

    // Make sure the script is executable
    fs.chmodSync(path.join(cherrypiqInstallDir, "cherrypiq.js"), "755");

    // Reinstall dependencies
    console.log("Reinstalling dependencies...");
    execSync("npm install", { cwd: cherrypiqInstallDir, stdio: "inherit" });

    // Relink the package
    console.log("Relinking package...");
    try {
      // Try to unlink first, but don't error if it fails
      execSync("npm unlink -g cherrypiq", {
        cwd: cherrypiqInstallDir,
        stdio: "inherit",
      });
    } catch (e) {
      // Ignore unlink errors - package might not be linked
    }
    // Now link the package
    execSync("npm link", { cwd: cherrypiqInstallDir, stdio: "inherit" });

    console.log("\nUpdate complete!");
    console.log("Your local changes have been installed.");
    console.log("\nYou can now use the updated cherrypiq from anywhere.");
    process.exit(0);
  } catch (error) {
    console.error("Error during update:", error.message);
    process.exit(1);
  }
}

// Check if repomix is installed
let repomixInstalled = false;
try {
  execSync("npx repomix --version", { stdio: "ignore" });
  repomixInstalled = true;
} catch (e) {
  console.error(
    "repomix is not installed. Install it with: npm install -g repomix"
  );
  process.exit(1);
}

// Check if ranger is installed
let rangerInstalled = false;
try {
  execSync("which ranger", { stdio: "ignore" });
  rangerInstalled = true;
} catch (e) {
  // Ranger not installed - that's fine
}

// Check if bat is installed
let batInstalled = false;
try {
  execSync("which bat", { stdio: "ignore" });
  batInstalled = true;
} catch (e) {
  try {
    execSync("which batcat", { stdio: "ignore" }); // For Ubuntu/Debian
    batInstalled = true;
  } catch (e) {
    // bat not installed - that's fine
  }
}

// Get bat command (handles both 'bat' and 'batcat' names)
function getBatCommand() {
  try {
    execSync("which bat", { stdio: "ignore" });
    return "bat";
  } catch (e) {
    return "batcat"; // For Ubuntu/Debian
  }
}

// Get gitignore patterns
async function getGitignorePatterns(dir) {
  const patterns = [];
  try {
    const gitignorePath = path.join(dir, ".gitignore");
    if (fs.existsSync(gitignorePath)) {
      const content = await readFile(gitignorePath, "utf8");
      patterns.push(
        ...content
          .split("\n")
          .filter((line) => line && !line.startsWith("#"))
          .map((line) => line.trim())
      );
    }
  } catch (e) {
    // No gitignore or can't read it - that's fine
  }
  return patterns;
}

// Check if a file should be ignored based on gitignore patterns
function shouldIgnore(filePath, patterns) {
  const relativePath = path.relative(process.cwd(), filePath);
  return patterns.some((pattern) => {
    if (pattern.startsWith("!")) {
      return false; // Negation patterns not supported here
    }
    if (pattern.endsWith("/")) {
      // Directory pattern
      return (
        relativePath.startsWith(pattern) || relativePath.includes("/" + pattern)
      );
    }
    // File pattern or glob pattern (simplified)
    return minimatch(relativePath, pattern);
  });
}

// Simplified minimatch function for basic globbing
function minimatch(filePath, pattern) {
  // Convert glob pattern to regex
  const regex = new RegExp(
    "^" +
    pattern
      .replace(/\./g, "\\.") // Escape dots
      .replace(/\*/g, ".*") // Convert * to .*
      .replace(/\?/g, ".") + // Convert ? to .
      "$"
  );
  return regex.test(filePath);
}

// Get directory content
async function getDirectoryContent(
  dir,
  gitignorePatterns,
  selectedFilesArray = []
) {
  const entries = await readdir(dir, { withFileTypes: true });
  const items = await Promise.all(
    entries.map(async (entry) => {
      const fullPath = path.join(dir, entry.name);
      const isDir = entry.isDirectory();
      const ignored = shouldIgnore(fullPath, gitignorePatterns);
      const selected = selectedFilesArray.includes(fullPath);

      return {
        name: entry.name,
        path: fullPath,
        isDir,
        ignored,
        selected,
      };
    })
  );

  // Sort: directories first, then files, alphabetically
  return items.sort((a, b) => {
    if (a.isDir && !b.isDir) return -1;
    if (!a.isDir && b.isDir) return 1;
    return a.name.localeCompare(b.name);
  });
}

// Launch ranger to select files
function launchRanger() {
  return new Promise((resolve, reject) => {
    // Create a temporary file to hold selected paths
    const tempFile = path.join(process.cwd(), ".repomix-selected-files");

    // Clean previous file if exists
    if (fs.existsSync(tempFile)) {
      fs.unlinkSync(tempFile);
    }

    console.log(
      "Launching ranger. Select files with space, then quit with q to return to cherrypiq."
    );

    // Launch ranger with a custom script to handle selection
    const rangerScript = `
      map <space> chain mark_files toggle=True; eval fm.copy(); eval [ for f in fm.copied_files: open(\"${tempFile}\", \"a\").write(f.path + \"\\n\") ]
    `;

    const scriptPath = path.join(process.cwd(), ".repomix-ranger-rc.conf");
    fs.writeFileSync(scriptPath, rangerScript);

    const ranger = spawn("ranger", ["--cmd", `source ${scriptPath}`], {
      stdio: "inherit",
    });

    ranger.on("close", (code) => {
      // Clean up the script
      if (fs.existsSync(scriptPath)) {
        fs.unlinkSync(scriptPath);
      }

      // Read selected files
      if (fs.existsSync(tempFile)) {
        try {
          const selections = fs
            .readFileSync(tempFile, "utf8")
            .split("\n")
            .filter((line) => line.trim());

          fs.unlinkSync(tempFile);
          resolve(selections);
        } catch (e) {
          reject(new Error("Failed to read selected files from ranger"));
        }
      } else {
        resolve([]);
      }
    });
  });
}

// Run repomix with selected files
function runRepomix(selectedFiles) {
  if (selectedFiles.length === 0) {
    console.log("No files selected. Exiting.");
    process.exit(0);
  }

  // Convert absolute paths to relative paths
  const relativePaths = selectedFiles.map((file) =>
    path.relative(process.cwd(), file)
  );

  // Create include pattern for repomix
  const includePattern = relativePaths.join(",");

  console.log(`Running repomix with ${selectedFiles.length} selected files...`);

  try {
    execSync(`npx repomix --include "${includePattern}"`, {
      stdio: "inherit",
    });
    console.log("Repomix completed successfully!");
  } catch (e) {
    console.error("Failed to run repomix:", e.message);
    process.exit(1);
  }
}

// Run repomix and copy output to clipboard
async function runRepomixToClipboard(selectedFiles) {
  if (selectedFiles.length === 0) {
    console.log("No files selected. Exiting.");
    process.exit(0);
  }

  // Convert absolute paths to relative paths
  const relativePaths = selectedFiles.map((file) =>
    path.relative(process.cwd(), file)
  );

  // Create include pattern for repomix
  const includePattern = relativePaths.join(",");

  try {
    const output = execSync(`npx repomix --include "${includePattern}"`, {
      encoding: "utf8",
    });
    await clipboardy.write(output);
    return true;
  } catch (e) {
    console.error("Failed to run repomix:", e.message);
    return false;
  }
}

// Create prompt input box
function createPromptInput(screen) {
  const promptBox = blessed.box({
    top: "center",
    left: "center",
    width: "80%",
    height: 7,
    hidden: true, // Hide by default
    content: "{bold}Enter Prompt for Repomix{/bold}",
    tags: true,
    border: {
      type: "line",
    },
    style: {
      border: {
        fg: "white",
      },
      focus: {
        border: {
          fg: "green",
        },
      },
    },
  });

  const promptInput = blessed.textbox({
    parent: promptBox,
    top: 2,
    left: 1,
    right: 1,
    height: 3,
    inputOnFocus: true,
    border: {
      type: "line",
    },
    style: {
      border: {
        fg: "white",
      },
      focus: {
        border: {
          fg: "green",
        },
      },
    },
  });

  // Add a small help text
  const helpText = blessed.box({
    parent: promptBox,
    bottom: 0,
    left: 1,
    content: "Enter: Submit | Esc: Cancel",
    style: {
      fg: "gray",
    },
  });

  return { promptBox, promptInput };
}

// Run repomix with custom prompt
async function runRepomixWithPrompt(selectedFiles, prompt) {
  if (selectedFiles.length === 0) {
    console.log("No files selected. Exiting.");
    process.exit(0);
  }

  // Convert absolute paths to relative paths
  const relativePaths = selectedFiles.map((file) =>
    path.relative(process.cwd(), file)
  );

  // Create include pattern for repomix
  const includePattern = relativePaths.join(",");

  try {
    const output = execSync(
      `npx repomix --include "${includePattern}" --prompt "${prompt}"`,
      {
        encoding: "utf8",
      }
    );
    return output;
  } catch (e) {
    console.error("Failed to run repomix:", e.message);
    return null;
  }
}

// Setup blessed UI
function setupUI() {
  const screen = blessed.screen({
    smartCSR: true,
    title: "cherrypiq",
    fullUnicode: true,
  });

  // Left column for file navigation
  const leftColumn = blessed.box({
    top: 0,
    left: 0,
    width: "60%",
    height: "100%",
    border: {
      type: "line",
    },
    style: {
      border: {
        fg: "white",
      },
    },
  });

  // File list
  const list = blessed.box({
    parent: leftColumn,
    top: 1, // Leave space for path display
    left: 0,
    width: "100%-2", // Account for borders
    height: "100%-4", // Account for borders and path display
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    scrollable: true,
    alwaysScroll: true,
    scrollbar: {
      ch: " ",
      track: {
        bg: "gray",
      },
      style: {
        inverse: true,
      },
    },
  });

  // Right column
  const rightColumn = blessed.box({
    top: 0,
    right: 0,
    width: "40%",
    height: "100%",
    border: {
      type: "line",
    },
    style: {
      border: {
        fg: "white",
      },
    },
  });

  // Token count display in top half of right column
  const tokenCount = blessed.box({
    parent: rightColumn,
    top: 1,
    left: 1,
    width: "100%-2",
    height: "30%",
    content: "Token Count: 0",
    tags: true,
    border: {
      type: "line",
    },
    style: {
      border: {
        fg: "white",
      },
    },
  });

  // Command help in bottom half of right column
  const commandHelp = blessed.box({
    parent: rightColumn,
    top: "30%",
    left: 1,
    width: "100%-2",
    height: "70%",
    content:
      "{bold}Commands{/bold}\n\n" +
      "Navigation:\n" +
      "  j/↓: Move down\n" +
      "  k/↑: Move up\n" +
      "  g: Go to top\n" +
      "  G: Go to bottom\n" +
      "  h/←: Go up dir\n" +
      "  l/→/enter: Open dir\n\n" +
      "Selection:\n" +
      "  space: Select file/dir\n" +
      "  p: Preview file\n" +
      "  esc: Close preview\n\n" +
      "Actions:\n" +
      "  r: Run repomix\n" +
      "  c: Copy to clipboard\n" +
      "  i: Input prompt\n" +
      "  R: Launch ranger\n" +
      "  ?: Toggle help\n" +
      "  q: Quit",
    tags: true,
    border: {
      type: "line",
    },
    style: {
      border: {
        fg: "white",
      },
    },
  });

  // Path display at top of left column
  const pathDisplay = blessed.box({
    parent: leftColumn,
    top: 0,
    left: 0,
    width: "100%-2",
    height: 1,
    content: process.cwd(),
    style: {
      bg: "blue",
      fg: "white",
    },
  });

  // Selected count display at bottom of left column
  const selectedCount = blessed.box({
    parent: leftColumn,
    bottom: 0,
    left: 0,
    width: "100%-2",
    height: 1,
    content: "Selected: 0",
    tags: true,
    style: {
      bg: "blue",
      fg: "white",
    },
  });

  // Preview popup for bat
  const previewBox = blessed.box({
    top: "center",
    left: "center",
    width: "80%",
    height: "80%",
    hidden: true,
    border: {
      type: "line",
    },
    style: {
      border: {
        fg: "white",
      },
    },
    tags: true,
    scrollable: true,
    alwaysScroll: true,
    keys: true,
    vi: true,
    mouse: true,
  });

  // Prompt input box
  const { promptBox, promptInput } = createPromptInput(screen);

  screen.append(leftColumn);
  screen.append(rightColumn);
  screen.append(previewBox);
  screen.append(promptBox);

  return {
    screen,
    list,
    pathDisplay,
    selectedCount,
    tokenCount,
    commandHelp,
    previewBox,
    promptBox,
    promptInput,
  };
}

// Main function
async function main() {
  const ui = setupUI();
  const {
    screen,
    list,
    pathDisplay,
    selectedCount,
    tokenCount,
    commandHelp,
    previewBox,
    promptBox,
    promptInput,
  } = ui;

  let currentDir = process.cwd();
  let currentItems = [];
  let selectedFiles = [];
  let selectedIndex = 0; // Current selection index
  let scrollOffset = 0; // Scroll offset for the list

  // Load initial directory
  const gitignorePatterns = await getGitignorePatterns(currentDir);
  currentItems = await getDirectoryContent(
    currentDir,
    gitignorePatterns,
    selectedFiles
  );

  // Calculate visible height (accounting for borders)
  const getVisibleHeight = () => list.height - 2;

  // Render the file list with custom implementation
  function renderList() {
    const visibleHeight = getVisibleHeight();

    // Ensure scroll offset is valid
    if (selectedIndex < scrollOffset) {
      scrollOffset = selectedIndex;
    } else if (selectedIndex >= scrollOffset + visibleHeight) {
      scrollOffset = selectedIndex - visibleHeight + 1;
    }

    // Create content for the box
    let content = "";

    // Only render visible items
    const visibleItems = currentItems.slice(
      scrollOffset,
      scrollOffset + visibleHeight
    );

    visibleItems.forEach((item, idx) => {
      const isSelected = idx + scrollOffset === selectedIndex;
      let prefix = item.isDir ? "[+] " : "    ";
      prefix = item.selected ? "{red-fg}[✓]{/red-fg} " : prefix;

      let display = item.name;
      if (item.isDir) {
        display = "{bold}" + display + "/{/bold}";
      }
      if (item.ignored) {
        display = "{grey-fg}" + display + "{/grey-fg}";
      }
      if (item.selected) {
        display = "{yellow-fg}" + display + "{/yellow-fg}";
      }

      // Highlight selected item
      if (isSelected) {
        content += `{blue-bg}${prefix}${display}{/blue-bg}\n`;
      } else {
        content += `${prefix}${display}\n`;
      }
    });

    // Set content and update UI
    list.setContent(content);
    selectedCount.setContent(`Selected: ${selectedFiles.length}`);
    screen.render();
  }

  // Initial render
  renderList();

  // Custom key handling
  screen.key(["j", "down"], () => {
    if (selectedIndex < currentItems.length - 1) {
      selectedIndex++;
      renderList();
    }
  });

  screen.key(["k", "up"], () => {
    if (selectedIndex > 0) {
      selectedIndex--;
      renderList();
    }
  });

  screen.key(["g", "home"], () => {
    if (currentItems.length > 0) {
      selectedIndex = 0;
      renderList();
    }
  });

  screen.key(["G", "end"], () => {
    if (currentItems.length > 0) {
      selectedIndex = currentItems.length - 1;
      renderList();
    }
  });

  screen.key(["C-d", "pagedown"], () => {
    const pageSize = Math.min(10, currentItems.length);
    selectedIndex = Math.min(selectedIndex + pageSize, currentItems.length - 1);
    renderList();
  });

  screen.key(["C-u", "pageup"], () => {
    const pageSize = Math.min(10, currentItems.length);
    selectedIndex = Math.max(selectedIndex - pageSize, 0);
    renderList();
  });

  // Space: select/deselect file
  screen.key("space", async () => {
    const item = currentItems[selectedIndex];
    if (!item || item.ignored) return;

    if (item.isDir) {
      // Toggle directory selection
      if (selectedFiles.includes(item.path)) {
        // Unmark directory and contents
        const idx = selectedFiles.findIndex((f) => f === item.path);
        if (idx !== -1) selectedFiles.splice(idx, 1);
        await markDirectory(item.path, false);
      } else {
        // Mark directory and contents
        selectedFiles.push(item.path);
        await markDirectory(item.path, true);
      }
    } else {
      // Toggle file selection
      item.selected = !item.selected;
      const idx = selectedFiles.findIndex((f) => f === item.path);

      if (item.selected && idx === -1) {
        selectedFiles.push(item.path);
      } else if (!item.selected && idx !== -1) {
        selectedFiles.splice(idx, 1);
      }
    }

    // Update UI and token count
    await updateTokenCount(selectedFiles, tokenCount);
    renderList();
  });

  // Enter: open directory
  screen.key(["enter", "l", "o", "right"], async () => {
    const item = currentItems[selectedIndex];
    if (item && item.isDir) {
      currentDir = item.path;
      currentItems = await getDirectoryContent(
        currentDir,
        gitignorePatterns,
        selectedFiles
      );
      selectedIndex = 0; // Reset selection to top
      scrollOffset = 0; // Reset scroll
      renderList();
    }
  });

  // Backspace/h/left: go up one directory
  screen.key(["backspace", "h", "left"], async () => {
    const parentDir = path.dirname(currentDir);
    if (parentDir !== currentDir) {
      currentDir = parentDir;
      currentItems = await getDirectoryContent(
        currentDir,
        gitignorePatterns,
        selectedFiles
      );
      selectedIndex = 0; // Reset selection to top
      scrollOffset = 0; // Reset scroll
      renderList();
    }
  });

  // r: run repomix with selected files
  screen.key("r", () => {
    if (!screen.focused.name === "list") return;
    screen.destroy();
    runRepomix(selectedFiles);
  });

  // R: launch ranger if installed
  screen.key("R", async () => {
    if (!rangerInstalled) {
      commandHelp.setContent(
        "{red-bg}Ranger is not installed!{/red-bg} Press any key to continue..."
      );
      screen.render();
      setTimeout(() => {
        commandHelp.setContent(
          "{bold}cherrypiq{/bold} | {bold}j/k{/bold}: navigate | {bold}space{/bold}: select | {bold}enter{/bold}: open dir | {bold}r{/bold}: run repomix | {bold}R{/bold}: ranger" +
            (rangerInstalled ? "" : " (not installed)") +
            " | {bold}q{/bold}: quit"
        );
        screen.render();
      }, 3000);
      return;
    }

    screen.destroy();
    console.log("Launching ranger...");

    try {
      const rangerSelectedFiles = await launchRanger();
      if (rangerSelectedFiles.length > 0) {
        selectedFiles = rangerSelectedFiles;
        console.log(`${selectedFiles.length} files selected from ranger.`);

        const rl = require("readline").createInterface({
          input: process.stdin,
          output: process.stdout,
        });

        rl.question("Run repomix with these selections? (y/n) ", (answer) => {
          rl.close();
          if (answer.toLowerCase() === "y") {
            runRepomix(selectedFiles);
          } else {
            main(); // Restart the UI
          }
        });
      } else {
        console.log("No files selected in ranger.");
        main(); // Restart the UI
      }
    } catch (e) {
      console.error("Error using ranger:", e.message);
      main(); // Restart the UI
    }
  });

  // q/Ctrl-c: quit
  screen.key(["q", "C-c"], () => {
    screen.destroy();
    process.exit(0);
  });

  // Mark/unmark all files in directory recursively
  async function markDirectory(dir, mark) {
    const dirItems = await getDirectoryContent(
      dir,
      gitignorePatterns,
      selectedFiles
    );
    for (const dirItem of dirItems) {
      if (dirItem.ignored) continue;

      if (dirItem.isDir) {
        await markDirectory(dirItem.path, mark);
      } else {
        const idx = selectedFiles.findIndex((f) => f === dirItem.path);
        if (mark && idx === -1) {
          selectedFiles.push(dirItem.path);
        } else if (!mark && idx !== -1) {
          selectedFiles.splice(idx, 1);
        }
      }
    }
  }

  // Calculate token count for a file
  async function calculateTokenCount(filePath) {
    try {
      const content = await readFile(filePath, "utf8");

      // Remove comments but preserve newlines to maintain line count
      const noComments = content
        .replace(/\/\*[\s\S]*?\*\//g, "") // Remove multi-line comments
        .replace(/\/\/.*/g, ""); // Remove single-line comments

      // Count non-empty lines
      const lines = noComments.split("\n").filter((line) => line.trim());

      // Tokenize the code more accurately
      const tokens = noComments
        // Add spaces around operators and punctuation
        .replace(/([{}()\[\].,;=+\-*/<>!&|%^~?:])/g, " $1 ")
        // Preserve string literals
        .replace(/'[^']*'|"[^"]*"|`[^`]*`/g, (match) =>
          match.replace(/\s/g, "")
        )
        // Normalize whitespace
        .replace(/\s+/g, " ")
        .trim()
        // Split into tokens
        .split(" ")
        // Remove empty tokens
        .filter((token) => token.length > 0);

      // Count characters excluding whitespace
      const chars = noComments.replace(/\s+/g, "").length;

      return {
        lines: lines.length,
        tokens: tokens.length,
        chars: chars,
      };
    } catch (error) {
      return { lines: 0, tokens: 0, chars: 0 };
    }
  }

  // Update token count display
  async function updateTokenCount(selectedFiles, tokenCount) {
    let totalLines = 0;
    let totalTokens = 0;
    let totalChars = 0;

    for (const file of selectedFiles) {
      const stats = await calculateTokenCount(file);
      totalLines += stats.lines;
      totalTokens += stats.tokens;
      totalChars += stats.chars;
    }

    tokenCount.setContent(
      "{bold}Code Statistics{/bold}\n\n" +
        `Selected Files: ${selectedFiles.length}\n` +
        `Lines of Code: ${totalLines}\n` +
        `Estimated Tokens: ${totalTokens}\n` +
        `Characters: ${totalChars}\n\n` +
        `Note: Comments excluded`
    );
  }

  // Preview file using bat
  async function previewFile(filePath, previewBox) {
    if (!batInstalled) {
      previewBox.setContent(
        "{red-fg}bat is not installed. Install it for file preview functionality.{/red-fg}"
      );
      previewBox.show();
      return;
    }

    try {
      const batCmd = getBatCommand();
      const output = execSync(
        `${batCmd} --color=always --style=numbers,changes "${filePath}"`,
        {
          encoding: "utf8",
          maxBuffer: 10 * 1024 * 1024, // 10MB buffer
        }
      );

      previewBox.setContent(output);
      previewBox.show();
    } catch (error) {
      previewBox.setContent(
        `{red-fg}Error previewing file: ${error.message}{/red-fg}`
      );
      previewBox.show();
    }
  }

  // Add preview key binding in main()
  screen.key("p", async () => {
    const item = currentItems[selectedIndex];
    if (!item || item.isDir) return;

    await previewFile(item.path, previewBox);
    screen.render();
  });

  // Add escape key to close preview
  screen.key("escape", () => {
    previewBox.hide();
    screen.render();
  });

  // Add key bindings for clipboard and prompt features
  screen.key("c", async () => {
    if (!screen.focused.name === "list") return;
    const success = await runRepomixToClipboard(selectedFiles);
    if (success) {
      screen.destroy();
      console.log("Repomix output copied to clipboard!");
    }
  });

  screen.key("i", () => {
    if (!screen.focused.name === "list") return;
    promptBox.show();
    promptInput.clearValue();
    promptInput.focus();
    screen.render();
  });

  promptInput.key(["enter"], async () => {
    const prompt = promptInput.getValue().trim();
    if (!prompt) {
      promptBox.hide();
      list.focus();
      screen.render();
      return;
    }

    promptBox.hide();
    screen.render();

    const output = await runRepomixWithPrompt(selectedFiles, prompt);
    if (output) {
      screen.destroy();
      console.log(output);
    }
  });

  promptInput.key(["escape"], () => {
    promptInput.clearValue();
    promptBox.hide();
    list.focus();
    screen.render();
  });

  // Focus handling
  list.focus();
  screen.render();
}

// Start the application
main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});

================
File: fix-cherrypiq.sh
================
#!/bin/bash

# fix-cherrypiq.sh
# This script fixes a broken cherrypiq installation

# Save the current directory
ORIGINAL_DIR=$(pwd)

echo "Fixing cherrypiq installation..."

# First, uninstall the broken installation
echo "Step 1: Uninstalling broken cherrypiq..."

# Remove any existing symlinks in common paths
for path in "/opt/homebrew/bin/cherrypiq" "/usr/local/bin/cherrypiq" "/usr/bin/cherrypiq"; do
    if [ -f "$path" ]; then
        echo "Removing symlink at $path..."
        sudo rm -f "$path" 2>/dev/null || {
            echo "Failed to remove symlink at $path. You may need to remove it manually:"
            echo "sudo rm -f $path"
        }
    fi
done

# Remove global npm link
echo "Removing global npm link..."
npm unlink -g cherrypiq 2>/dev/null || npm uninstall -g cherrypiq 2>/dev/null

# Remove ranger integration if it exists
if [ -f /usr/local/bin/ranger-repomix ]; then
    echo "Removing ranger integration..."
    sudo rm -f /usr/local/bin/ranger-repomix 2>/dev/null || {
        echo "Failed to remove ranger integration symlink. You may need to remove it manually:"
        echo "sudo rm -f /usr/local/bin/ranger-repomix"
    }
fi

# Remove cherrypiq directory
echo "Removing cherrypiq files..."
if [ -d ~/.cherrypiq ]; then
    rm -rf ~/.cherrypiq
    echo "Removed ~/.cherrypiq directory"
fi

# Now reinstall using local files
echo "Step 2: Reinstalling cherrypiq from local files..."

# Create directory for the tool
mkdir -p ~/.cherrypiq

# Check if nodejs and npm are installed
if ! command -v node &> /dev/null; then
    echo "Error: Node.js is required but not installed."
    echo "Please install Node.js and npm first, then run this script again."
    exit 1
fi

if ! command -v npm &> /dev/null; then
    echo "Error: npm is required but not installed."
    echo "Please install npm first, then run this script again."
    exit 1
fi

# Install required packages globally
echo "Installing global dependencies..."
npm install -g repomix blessed

# Create package.json
cat > ~/.cherrypiq/package.json << 'EOF'
{
  "name": "cherrypiq",
  "version": "0.1.0",
  "description": "Interactive file selector for repomix",
  "main": "cherrypiq.js",
  "bin": {
    "cherrypiq": "./cherrypiq.js"
  },
  "dependencies": {
    "blessed": "^0.1.81"
  }
}
EOF

# Install local dependencies
echo "Installing local dependencies..."
(cd ~/.cherrypiq && npm install)

# Copy the local cherrypiq.js file or download from GitHub if not found
echo "Setting up cherrypiq script..."
if [ -f "./cherrypiq.js" ] || [ -f "./cherrypiq.js" ] || [ -f "./index.js" ]; then
    # Try to copy from local files
    if [ -f "./cherrypiq.js" ]; then
        cp ./cherrypiq.js ~/.cherrypiq/cherrypiq.js
        echo "Copied local cherrypiq.js script"
    elif [ -f "./cherrypiq.js" ]; then
        cp ./cherrypiq.js ~/.cherrypiq/cherrypiq.js
        echo "Copied local cherrypiq.js script"
    elif [ -f "./index.js" ]; then
        cp ./index.js ~/.cherrypiq/cherrypiq.js
        echo "Copied local index.js script"
    fi
else
    # If no local file found, download from GitHub
    echo "No local script found, downloading from GitHub..."
    curl -o ~/.cherrypiq/cherrypiq.js https://raw.githubusercontent.com/ya1sec/cherrypiq/main/cherrypiq.js || {
        echo "Error: Failed to download script from GitHub."
        echo "Please ensure you're running this script from the cherrypiq repository directory"
        echo "or have an internet connection to download from GitHub."
        exit 1
    }
fi

# Make the script executable
chmod +x ~/.cherrypiq/cherrypiq.js

# Create global symlink
echo "Creating global symlink..."
(cd ~/.cherrypiq && npm link)

# Setup ranger integration if ranger is installed
if command -v ranger &> /dev/null; then
    echo "Ranger detected, installing ranger integration..."
    if [ -f "./ranger-integration.sh" ]; then
        cp ./ranger-integration.sh ~/.cherrypiq/ranger-repomix-integration.sh
    else
        # Download from GitHub if local file not found
        curl -o ~/.cherrypiq/ranger-repomix-integration.sh https://raw.githubusercontent.com/ya1sec/cherrypiq/main/ranger-repomix-integration.sh || {
            echo "Warning: Failed to setup ranger integration."
            echo "You can try setting it up later by running the installation script again."
        }
    fi
    
    if [ -f ~/.cherrypiq/ranger-repomix-integration.sh ]; then
        chmod +x ~/.cherrypiq/ranger-repomix-integration.sh
        sudo ln -sf ~/.cherrypiq/ranger-repomix-integration.sh /usr/local/bin/ranger-repomix || {
            echo "Failed to create global symlink for ranger integration. You may need sudo:"
            echo "sudo ln -sf ~/.cherrypiq/ranger-repomix-integration.sh /usr/local/bin/ranger-repomix"
        }
    fi
fi

# Return to original directory
cd "$ORIGINAL_DIR"

echo "Installation fixed!"
echo "You can now use cherrypiq from anywhere."
echo ""
echo "Commands:"
echo "  cherrypiq    - Launch the interactive file selector"
if command -v ranger &> /dev/null; then
    echo "  ranger-repomix      - Launch ranger with repomix integration"
fi
echo ""
echo "Enjoy!"

================
File: install-cherrypiq.sh
================
#!/bin/bash

# install-cherrypiq.sh
# This script installs the cherrypiq tool

# Save the current directory
ORIGINAL_DIR=$(pwd)

echo "Installing cherrypiq..."

# Create directory for the tool
mkdir -p ~/.cherrypiq

# Check if nodejs and npm are installed
if ! command -v node &> /dev/null; then
    echo "Error: Node.js is required but not installed."
    echo "Please install Node.js and npm first, then run this script again."
    exit 1
fi

if ! command -v npm &> /dev/null; then
    echo "Error: npm is required but not installed."
    echo "Please install npm first, then run this script again."
    exit 1
fi

# Install required packages
echo "Installing dependencies..."
npm install -g repomix blessed clipboardy@2.3.0

# Create package.json
cat > ~/.cherrypiq/package.json << 'EOF'
{
  "name": "cherrypiq",
  "version": "0.1.0",
  "description": "Interactive file selector for repomix",
  "main": "cherrypiq.js",
  "bin": {
    "cherrypiq": "./cherrypiq.js"
  },
  "dependencies": {
    "blessed": "^0.1.81",
    "clipboardy": "^2.3.0"
  }
}
EOF

# Install dependencies in the cherrypiq directory
echo "Installing local dependencies..."
(cd ~/.cherrypiq && npm install)

# Install cherrypiq script
echo "Installing cherrypiq script..."
if [ -f "cherrypiq.js" ]; then
    echo "Using local cherrypiq.js..."
    cp cherrypiq.js ~/.cherrypiq/cherrypiq.js
else
    echo "Local cherrypiq.js not found, downloading from GitHub..."
    curl -o ~/.cherrypiq/cherrypiq.js https://raw.githubusercontent.com/ya1sec/cherrypiq/main/cherrypiq.js || {
        echo "Error: Failed to download cherrypiq.js from GitHub."
        echo "Please ensure you have a local copy of cherrypiq.js or internet connection."
        exit 1
    }
fi

# Make the script executable
chmod +x ~/.cherrypiq/cherrypiq.js

# Create global symlink
echo "Creating global symlink..."
cd ~/.cherrypiq && npm link

# Handle ranger integration if ranger is installed
if command -v ranger &> /dev/null; then
    echo "Ranger detected, installing ranger integration..."
    
    # Create ranger integration directory
    mkdir -p ~/.cherrypiq/ranger

    # Install ranger integration script
    echo "Installing ranger integration script..."
    if [ -f "ranger-repomix.sh" ]; then
        echo "Using local ranger-repomix.sh..."
        cp ranger-repomix.sh ~/.cherrypiq/ranger/ranger-repomix.sh
    else
        echo "Creating ranger integration script..."
        cat > ~/.cherrypiq/ranger/ranger-repomix.sh << 'EOF'
#!/bin/bash

# ranger-repomix.sh
# This script helps integrate ranger file manager with repomix

# Create a temporary rc.conf for ranger
TEMP_RC_CONF="/tmp/ranger_repomix_rc.conf"
SELECTED_FILES="/tmp/repomix_selected_files.txt"

# Clean up any existing file
rm -f "$SELECTED_FILES"
touch "$SELECTED_FILES"

# Create ranger configuration for file selection
cat > "$TEMP_RC_CONF" << 'RANGERCONF'
# Repomix integration for ranger

# Mark files with space and save to repomix selection file
map <space> chain mark_files toggle=True; shell echo %p >> /tmp/repomix_selected_files.txt

# Custom command to run repomix with selected files
map ,r shell cat /tmp/repomix_selected_files.txt | sort | uniq | tr '\n' ',' | xargs -I{} repomix --include "{}"

# Show help information
map ,h shell echo "Repomix Integration Help:\n\n<space> - Mark/unmark file for inclusion\n,r - Run repomix with selected files\n,h - Show this help\n,c - Clear selection" | less

# Clear selection
map ,c shell rm -f /tmp/repomix_selected_files.txt && touch /tmp/repomix_selected_files.txt && echo "Selection cleared"
RANGERCONF

# Launch ranger with the custom configuration
echo "=== Ranger-Repomix Integration ==="
echo "Use <space> to select files for repomix"
echo "Press ,r to run repomix with selected files"
echo "Press ,h for help"
echo "Press ,c to clear selection"
echo "===============================>"

ranger --cmd="source $TEMP_RC_CONF"

# Clean up
rm -f "$TEMP_RC_CONF"

# Check if any files were selected and not processed
if [ -s "$SELECTED_FILES" ]; then
    echo "You still have selected files that were not processed."
    echo "Would you like to run repomix with these files? (y/n)"
    read -r answer
    
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        # Get unique files and convert to comma-separated list
        INCLUDE_LIST=$(cat "$SELECTED_FILES" | sort | uniq | tr '\n' ',')
        # Remove trailing comma
        INCLUDE_LIST=${INCLUDE_LIST%,}
        
        echo "Running: repomix --include \"$INCLUDE_LIST\""
        repomix --include "$INCLUDE_LIST"
    fi
fi

# Final cleanup
rm -f "$SELECTED_FILES"
echo "Done."
EOF
    fi

    # Make ranger integration script executable
    chmod +x ~/.cherrypiq/ranger/ranger-repomix.sh

    # Create user-local bin directory if it doesn't exist
    mkdir -p ~/bin

    # Create symlink in user's bin directory
    ln -sf ~/.cherrypiq/ranger/ranger-repomix.sh ~/bin/ranger-repomix
    
    # Add ~/bin to PATH if not already there
    if [[ ":$PATH:" != *":$HOME/bin:"* ]]; then
        echo 'export PATH="$HOME/bin:$PATH"' >> ~/.zshrc
        echo 'export PATH="$HOME/bin:$PATH"' >> ~/.bashrc
        echo "Added ~/bin to PATH. Please restart your shell or run: source ~/.zshrc (or ~/.bashrc)"
    fi

    echo "Ranger integration installed in ~/bin/ranger-repomix"
fi

# Return to original directory
cd "$ORIGINAL_DIR"

echo "Installation complete!"
echo "You can now use cherrypiq from anywhere."
echo ""
echo "Commands:"
echo "  cherrypiq    - Launch the interactive file selector"
if command -v ranger &> /dev/null; then
    echo "  ranger-repomix      - Launch ranger with repomix integration"
fi
echo ""
echo "Enjoy!"



================================================================
End of Codebase
================================================================
